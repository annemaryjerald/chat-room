<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Dev Chat Terminal</title>
    <style>
        /* (styles unchanged from your file) */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Consolas','Monaco','Courier New',monospace; background: #1e1e1e; color: #d4d4d4; height:100vh; overflow:hidden; }
        .editor-container { display:flex; height:100vh; flex-direction:column; }
        .top-bar { background:#323233; height:35px; display:flex; align-items:center; padding:0 12px; border-bottom:1px solid #1e1e1e;}
        .window-controls { display:flex; gap:8px; margin-right:15px;}
        .control-btn{ width:12px; height:12px; border-radius:50%; border:none; cursor:pointer;}
        .control-btn.close{ background:#ff5f56 } .control-btn.minimize{ background:#ffbd2e } .control-btn.maximize{ background:#27c93f }
        .file-tab { background:#1e1e1e; padding:6px 16px; border-right:1px solid #252526; display:flex; align-items:center; gap:8px; font-size:13px; }
        .file-icon { color:#4ec9b0 }
        .main-content { display:flex; flex:1; overflow:hidden; }
        .sidebar { width:50px; background:#333333; border-right:1px solid #1e1e1e; display:flex; flex-direction:column; align-items:center; padding-top:10px; }
        .sidebar-icon { width:48px; height:48px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:24px; border-left:2px solid transparent; transition:all 0.2s; position:relative; }
        .sidebar-icon:hover{ background:#2a2d2e } .sidebar-icon.active{ border-left-color:#007acc }
        .editor-area{ flex:1; display:flex; flex-direction:column; background:#1e1e1e }
        .setup-screen{ flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:25px; padding:20px }
        .setup-title{ font-size:24px; color:#4ec9b0 }
        .setup-input{ background:#3c3c3c; border:1px solid #3e3e42; color:#d4d4d4; padding:12px 20px; border-radius:4px; font-family:'Consolas',monospace; font-size:14px; width:300px; text-align:center }
        .setup-input:focus{ outline:none; border-color:#007acc }
        .setup-btn{ background:#007acc; color:white; border:none; padding:12px 32px; border-radius:4px; cursor:pointer; font-family:'Consolas',monospace; font-size:14px; font-weight:bold; transition:all 0.2s }
        .setup-btn:hover{ background:#0098ff }
        .chat-container{ flex:1; overflow-y:auto; padding:20px; display:flex; flex-direction:column; gap:15px }
        .chat-container::-webkit-scrollbar{ width:10px } .chat-container::-webkit-scrollbar-track{ background:#1e1e1e } .chat-container::-webkit-scrollbar-thumb{ background:#424242; border-radius:5px }
        .message{ display:flex; gap:12px; animation:fadeIn 0.3s ease; max-width:85%; position:relative }
        @keyframes fadeIn{ from{ opacity:0; transform:translateY(10px) } to{ opacity:1; transform:translateY(0) } }
        .message.own{ align-self:flex-end; flex-direction:row-reverse }
        .message-avatar{ width:32px; height:32px; border-radius:4px; display:flex; align-items:center; justify-content:center; font-size:18px; flex-shrink:0; font-weight:bold }
        .avatar-1{ background:linear-gradient(135deg,#667eea 0%,#764ba2 100%) } .avatar-2{ background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%) } .avatar-3{ background:linear-gradient(135deg,#4facfe 0%,#00f2fe 100%) } .avatar-4{ background:linear-gradient(135deg,#43e97b 0%,#38f9d7 100%) } .avatar-5{ background:linear-gradient(135deg,#fa709a 0%,#fee140 100%) }
        .message-content{ flex:1 } .message-header{ display:flex; gap:8px; align-items:center; margin-bottom:6px; font-size:13px } .message-author{ color:#4ec9b0; font-weight:bold } .message-time{ color:#858585; font-size:11px }
        .message-text{ background:#2d2d2d; padding:12px 15px; border-radius:6px; border-left:3px solid #007acc; line-height:1.6; font-size:14px; color:#d4d4d4; word-wrap:break-word; position:relative }
        .message-text.deleted{ background:#3a2d2d; border-left-color:#ff5f56; font-style:italic; color:#858585 }
        .message.own .message-text{ border-left-color:#667eea; background:#2a2a3e }
        .delete-btn{ position:absolute; top:-12px; right:10px; background:#3c3c3c; border:1px solid #3e3e42; border-radius:12px; padding:4px 8px; cursor:pointer; font-size:14px; opacity:0; transition:all 0.2s; z-index:10; color:#ff5f56 }
        .delete-btn:hover{ background:#ff5f56; color:white; transform:scale(1.1) } .message.own .message-text:hover .delete-btn{ opacity:1 }
        .system-message{ text-align:center; padding:8px; color:#858585; font-size:12px; font-style:italic }
        .input-area{ background:#252526; border-top:1px solid #3e3e42; padding:15px; display:flex; gap:10px; align-items:flex-end }
        .input-wrapper{ flex:1; position:relative }
        .attachment-btn{ position:absolute; right:10px; bottom:10px; background:transparent; border:none; color:#858585; cursor:pointer; font-size:20px; padding:4px 8px; border-radius:4px; transition:all 0.2s }
        .attachment-btn:hover{ color:#007acc; background:#3c3c3c }
        #fileInput{ display:none }
        #messageInput{ width:100%; background:#3c3c3c; border:1px solid #3e3e42; color:#d4d4d4; padding:12px 50px 12px 15px; border-radius:4px; font-family:'Consolas','Monaco',monospace; font-size:14px; resize:none; min-height:44px; max-height:120px; transition:border-color 0.2s }
        #messageInput:focus{ outline:none; border-color:#007acc } #messageInput::placeholder{ color:#6a6a6a }
        .send-btn{ background:#007acc; color:white; border:none; padding:12px 24px; border-radius:4px; cursor:pointer; font-family:'Consolas',monospace; font-size:14px; font-weight:bold; transition:all 0.2s; display:flex; align-items:center; gap:6px; height:44px }
        .send-btn:hover{ background:#0098ff }
        .status-bar{ background:#007acc; height:22px; display:flex; align-items:center; justify-content:space-between; padding:0 12px; font-size:12px; color:white }
        .status-left,.status-right{ display:flex; gap:15px } .status-item{ display:flex; align-items:center; gap:5px }
        .welcome-screen{ flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:20px; color:#858585 } .welcome-icon{ font-size:64px; opacity:0.5 } .welcome-text{ text-align:center; font-size:16px; line-height:1.6 }
        .hidden{ display:none } .info-box{ background:#2d2d2d; border:1px solid #3e3e42; border-left:3px solid #007acc; padding:15px; border-radius:4px; color:#d4d4d4; max-width:500px; line-height:1.6 } .info-box strong{ color:#4ec9b0 }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="top-bar">
            <div class="window-controls">
                <button class="control-btn close"></button>
                <button class="control-btn minimize"></button>
                <button class="control-btn maximize"></button>
            </div>
            <div class="file-tab">
                <span class="file-icon">‚óÜ</span>
                <span>private-chat.dev</span>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="sidebar-icon active" title="Chat">üí¨</div>
                <div class="sidebar-icon" title="Online Users">üë•</div>
                <div class="sidebar-icon" id="settingsBtn" title="Settings" onclick="toggleSettings()">‚öôÔ∏è</div>
            </div>

            <div class="editor-area">
                <div class="setup-screen" id="setupScreen">
                    <div class="welcome-icon">üë®‚Äçüíª</div>
                    <div class="setup-title">// Enter your username</div>
                    <div class="info-box" id="firstTimeInfo">
                        <strong>How this works:</strong><br>
                        Messages are stored in your browser's local storage with <strong>end-to-end encryption</strong>. Both you and your friend need to open this <strong>same URL</strong> and use the <strong>same encryption key</strong> to see each other's messages. If you configure Firebase (optional) the messages will sync in real-time between browsers. <strong>Security:</strong> All messages are encrypted - only people with the correct key can read them!
                    </div>
                    <input type="text" id="usernameInput" class="setup-input" placeholder="username" maxlength="20" />
                    <input type="password" id="encryptionKeyInput" class="setup-input" placeholder="encryption key (share with friend)" maxlength="50" style="margin-top:10px;" />
                    <div style="display:flex; align-items:center; gap:10px; margin-top:15px; color:#d4d4d4; font-size:13px;">
                        <input type="checkbox" id="rememberMe" style="width:18px; height:18px; cursor:pointer;">
                        <label for="rememberMe" style="cursor:pointer;">Remember me on this device</label>
                    </div>
                    <div style="color:#858585; font-size:12px; max-width:400px; text-align:center; margin-top:10px;">
                        üîë Choose a secret key and share it privately with friends. Both must use the same key.
                    </div>
                    <button class="setup-btn" onclick="joinChat()">Join Chat</button>
                    <button class="setup-btn" onclick="clearSavedCredentials()" style="background:#3c3c3c; margin-top:10px; display:none;" id="clearCredsBtn">Clear Saved Login</button>
                </div>

                <div class="chat-container hidden" id="chatContainer">
                    <div class="welcome-screen">
                        <div class="welcome-icon">üí¨</div>
                        <div class="welcome-text">
                            <strong>Chat initialized successfully</strong><br>
                            Waiting for messages...
                        </div>
                    </div>
                </div>

                <div class="input-area hidden" id="inputArea">
                    <div class="input-wrapper">
                        <textarea id="messageInput" placeholder="// Type your message here..." rows="1"></textarea>
                        <button class="attachment-btn" onclick="document.getElementById('fileInput').click()" title="Attach image or video">üìé</button>
                        <input type="file" id="fileInput" accept="image/*,video/*" onchange="handleFileSelect(event)">
                    </div>
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()"><span>‚ñ∂</span> Send</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-left">
                <div class="status-item"><span>‚óÜ</span><span id="roomInfo">Private Chat</span></div>
                <div class="status-item"><span>üì®</span><span id="messageCount">0 messages</span></div>
            </div>
            <div class="status-right">
                <div class="status-item"><span>üë§</span><span id="currentUser">Not connected</span></div>
                <div class="status-item"><span id="connectionStatusDot">‚óè</span><span id="status">Ready</span></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs (compat) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.22.0/firebase-database-compat.min.js"></script>

    <script>
    /*
      Integrated changes:
      - Inserted your Firebase config (adapted for compat usage).
      - Uses Realtime Database when firebase config is present (falls back to localStorage when not).
      - Safe base64 helpers, dedupe rendering, off() before on(), push() for sending.
      - Does NOT write decrypted content back to DB/localStorage.
      - Adds unhandledrejection logging for clearer errors in the console.
    */

    // ---------- Firebase configuration (from your pasted SDK) ----------
    // Note: this is the client config. If you use Realtime Database, you may need to add `databaseURL: "https://<your-db>.firebaseio.com"` or the -default-rtdb URL from your console.
    const firebaseConfig = {
      apiKey: "AIzaSyDaqPkJJa0rYcwMYgdBqHYxm7rPfFp4VCQ",
      authDomain: "dev-chat-789cc.firebaseapp.com",
      projectId: "dev-chat-789cc",
      storageBucket: "dev-chat-789cc.firebasestorage.app",
      messagingSenderId: "1059877701336",
      appId: "1:1059877701336:web:61ba71a9a76496ed17b9ad",
      measurementId: "G-1LY3S1G7CE",
      databaseURL: "https://dev-chat-789cc-default-rtdb.firebaseio.com"
    };

    // ---------- App state ----------
    let username = '';
    // derive roomId from hash (or create new)
    let roomId = 'default-room';
    if (window.location.hash) {
      roomId = window.location.hash.substring(1);
    } else {
      roomId = 'room_' + Math.random().toString(36).substring(2,9);
      window.location.hash = roomId;
    }

    // storage keys (depend on roomId)
    const STORAGE_KEY = 'chat_messages_' + roomId;
    const READ_RECEIPTS_KEY = 'chat_read_receipts_' + roomId;
    const REACTIONS_KEY = 'chat_reactions_' + roomId;
    const SETTINGS_KEY = 'chat_settings_' + roomId;
    const CREDENTIALS_KEY = 'chat_credentials_' + roomId;
    const FIRST_TIME_KEY = 'chat_first_time_' + roomId;

    let pendingFile = null;
    let lastMessageCount = 0;
    let notificationsEnabled = false;
    let dndEnabled = false;
    let dndMode = 'scheduled';
    let soundEnabled = true;
    let isWindowFocused = true;
    let encryptionKey = '';

    // Firebase runtime state
    let firebaseApp = null;
    let database = null;
    let messagesRef = null;
    let isFirebaseConfigured = false;
    let isFirebaseConnected = false;
    let messagesListenerAttached = false;

    // crypto cache and dedupe set
    let cachedCryptoKey = null;
    const renderedFirebaseIds = new Set();

    // ---------- Initialize Firebase (compat) ----------
    try {
      // If the apiKey looks like a placeholder, don't initialize
      const placeholder = firebaseConfig.apiKey && firebaseConfig.apiKey.includes('demo-key-replace-this');
      if (!placeholder) {
        firebaseApp = firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        isFirebaseConfigured = true;

        // If you added databaseURL to firebaseConfig in the object above, database.ref() will connect correctly.
        // Monitor connection status (if the DB exists and rules permit).
        try {
          database.ref('.info/connected').on('value', snap => {
            isFirebaseConnected = !!snap.val();
            updateConnectionUI();
            if (isFirebaseConnected && username) {
              attachMessagesListener();
            }
          });
        } catch (e) {
          console.warn('Realtime DB connection monitor not available:', e);
          isFirebaseConnected = false;
          updateConnectionUI();
        }

        messagesRef = database.ref('rooms/' + roomId + '/messages');
      } else {
        console.warn('Detected placeholder Firebase config ‚Äî running in local mode. Replace firebaseConfig with your project config to enable realtime sync.');
        isFirebaseConfigured = false;
        isFirebaseConnected = false;
      }
    } catch (err) {
      console.error('Firebase initialization error:', err);
      isFirebaseConfigured = false;
      isFirebaseConnected = false;
    }

    function updateConnectionUI() {
      document.getElementById('status').textContent = isFirebaseConnected ? 'Connected (Realtime)' : 'Demo Mode (local only)';
      const dot = document.getElementById('connectionStatusDot');
      dot.style.color = isFirebaseConnected ? '#27c93f' : '#ff5f56';
    }

    // ---------- Safe base64 helpers ----------
    function bytesToBase64(bytes) {
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }
    function base64ToBytes(b64) {
      const binary = atob(b64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
    }

    // ---------- Crypto helpers ----------
    async function getEncryptionKey(passphrase) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey('raw', encoder.encode(passphrase), { name: 'PBKDF2' }, false, ['deriveBits','deriveKey']);
      return await crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: encoder.encode('chat-room-salt-2024'),
        iterations: 100000,
        hash: 'SHA-256'
      }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt','decrypt']);
    }
    async function encryptMessage(text, key) {
      const encoder = new TextEncoder();
      const data = encoder.encode(text);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
      const combined = new Uint8Array(iv.length + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.length);
      return bytesToBase64(combined);
    }
    async function decryptMessage(encryptedText, key) {
      try {
        const combined = base64ToBytes(encryptedText);
        const iv = combined.slice(0, 12);
        const encrypted = combined.slice(12);
        const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);
        const decoder = new TextDecoder();
        return decoder.decode(decrypted);
      } catch (err) {
        console.warn('decryptMessage error (may be wrong key):', err);
        return '[Encrypted - Wrong Key]';
      }
    }

    // ---------- Firebase listener (safe attach/dedupe) ----------
    function attachMessagesListener() {
      if (!isFirebaseConfigured || !messagesRef) return;
      try { messagesRef.off(); } catch (e) { /* ignore */ }
      messagesRef.on('child_added', async snap => {
        try {
          const id = snap.key;
          const data = snap.val();
          if (!id || !data) return;
          if (renderedFirebaseIds.has(id)) return;

          if (!cachedCryptoKey && encryptionKey) {
            try { cachedCryptoKey = await getEncryptionKey(encryptionKey); } catch(e){ console.warn('derive key failed', e); }
          }

          // Build consistent local message object
          const msg = {
            author: data.author || 'Anonymous',
            content: data.content,
            encrypted: !!data.encrypted,
            time: data.time || new Date(data.ts || Date.now()).toLocaleTimeString(),
            timestamp: data.ts || Date.now(),
            firebaseId: id,
            media: data.media || null
          };

          // Add to local storage if not present
          const messages = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
          const exists = messages.some(m => m.firebaseId === id);
          if (!exists) {
            messages.push(msg);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
          }

          renderedFirebaseIds.add(id);
          await renderMessages();
        } catch (err) {
          console.error('Error in child_added handler:', err);
        }
      });
      messagesListenerAttached = true;
      console.log('Firebase listener attached for room:', roomId);
    }

    // ---------- sendMessage (push to Firebase if available; otherwise local) ----------
    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text && !pendingFile) return;

      if (!encryptionKey) { alert('Encryption key missing. Please join again with a key.'); return; }
      try {
        if (!cachedCryptoKey) cachedCryptoKey = await getEncryptionKey(encryptionKey);
      } catch (e) {
        console.error('Cannot derive crypto key:', e);
        alert('Encryption error ‚Äî check your key.');
        return;
      }

      const messageText = text || (pendingFile ? `Shared ${pendingFile.name}` : '');
      const encrypted = await encryptMessage(messageText, cachedCryptoKey);
      const payload = {
        author: username || 'Anonymous',
        content: encrypted,
        encrypted: true,
        time: getCurrentTime(),
        ts: Date.now(),
        media: pendingFile || null
      };

      if (isFirebaseConfigured && isFirebaseConnected && messagesRef) {
        try {
          const newRef = messagesRef.push();
          await newRef.set(payload);
          // rely on child_added to add it to local storage / UI
        } catch (err) {
          console.error('Failed to push message to Firebase:', err);
          alert('Failed to send via Firebase ‚Äî saved locally instead.');
          saveMessageLocally(payload);
        }
      } else {
        saveMessageLocally(payload);
      }

      input.value = '';
      autoResize(input);
      clearFilePreview();
    }

    function saveMessageLocally(payload) {
      const messages = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      messages.push(payload);
      if (messages.length > 200) messages.splice(0, messages.length - 200);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
      renderMessages();
    }

    // ---------- Rendering & local operations ----------
    function getInitials(name) { return (name || '?').substring(0,2).toUpperCase(); }
    function getAvatarClass(name) {
      const hash = (name || '').split('').reduce((acc, ch) => acc + ch.charCodeAt(0), 0);
      return `avatar-${(hash % 5) + 1}`;
    }
    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
    }

    async function renderMessages() {
      const container = document.getElementById('chatContainer');
      let messages = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

      container.innerHTML = '';
      if (!messages || messages.length === 0) {
        container.innerHTML = `<div class="welcome-screen"><div class="welcome-icon">üí¨</div><div class="welcome-text"><strong>Chat initialized</strong><br>Start typing to send a message...</div></div>`;
        document.getElementById('messageCount').textContent = '0 messages';
        return;
      }

      let cryptoKey = null;
      if (encryptionKey) {
        try { cryptoKey = cachedCryptoKey || await getEncryptionKey(encryptionKey); cachedCryptoKey = cryptoKey; } catch(e){ console.warn('render derive key failed', e); cryptoKey = null; }
      }

      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const div = document.createElement('div');
        div.className = 'message ' + (msg.author === username ? 'own' : '');
        const initials = getInitials(msg.author);
        const avatarClass = getAvatarClass(msg.author);

        let display = msg.content;
        if (msg.encrypted) {
          if (cryptoKey) display = await decryptMessage(msg.content, cryptoKey);
          else display = '[Encrypted - join with the correct key to view]';
        }

        let mediaHTML = '';
        if (msg.media && !msg.deleted) {
          if (msg.media.type && msg.media.type.startsWith('image/')) {
            mediaHTML = `<div class="message-media"><img src="${msg.media.data}" alt="${escapeHtml(msg.media.name)}" onclick="window.open(this.src,'_blank')"></div>`;
          } else if (msg.media.type && msg.media.type.startsWith('video/')) {
            mediaHTML = `<div class="message-media"><video controls><source src="${escapeHtml(msg.media.data)}" type="${escapeHtml(msg.media.type)}"></video></div>`;
          }
        }

        const deleteBtn = msg.author === username && !msg.deleted ? `<button class="delete-btn" onclick="deleteLocalMessage(${i})" title="Delete message">üóëÔ∏è</button>` : '';

        div.innerHTML = `
          <div class="message-avatar ${avatarClass}">${initials}</div>
          <div class="message-content">
            <div class="message-header">
              <span class="message-author">${escapeHtml(msg.author)}</span>
              <span class="message-time">${escapeHtml(msg.time || new Date(msg.timestamp || Date.now()).toLocaleTimeString())}</span>
            </div>
            <div class="message-text ${msg.deleted ? 'deleted' : ''}">
              ${escapeHtml(display).replace(/\n/g,'<br>')}
              ${deleteBtn}
            </div>
            ${mediaHTML}
          </div>
        `;
        container.appendChild(div);
      }

      container.scrollTop = container.scrollHeight;
      document.getElementById('messageCount').textContent = `${messages.length} message${messages.length !== 1 ? 's' : ''}`;
    }

    function deleteLocalMessage(index) {
      if (!confirm('Delete this message? This action cannot be undone.')) return;
      const messages = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      if (messages[index]) {
        const msg = messages[index];
        if (msg.firebaseId && isFirebaseConfigured && isFirebaseConnected && messagesRef) {
          messagesRef.child(msg.firebaseId).remove().catch(err => console.error('Failed removing remote message:', err));
        }
        messages.splice(index, 1);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(messages));
        renderMessages();
      }
    }

    // ---------- localStorage polling fallback ----------
    let localPollInterval = null;
    function startLocalPolling() {
      if (localPollInterval) return;
      localPollInterval = setInterval(() => { loadMessages(); }, 1500);
    }
    function stopLocalPolling() { if (localPollInterval) { clearInterval(localPollInterval); localPollInterval = null; } }

    function loadMessages() {
      if (isFirebaseConfigured && isFirebaseConnected) return;
      const messages = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      if (messages.length > lastMessageCount) {
        const newMessages = messages.slice(lastMessageCount);
        newMessages.forEach(m => { if (m.author !== username) showNotification(m); });
      }
      lastMessageCount = messages.length;
      renderMessages();
    }

    // ---------- file handling ----------
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      if (file.size > 5 * 1024 * 1024) { alert('File size must be less than 5MB'); event.target.value = ''; return; }
      if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) { alert('Only images and videos are supported'); event.target.value = ''; return; }
      const reader = new FileReader();
      reader.onload = function(e) {
        pendingFile = { name: file.name, type: file.type, data: e.target.result };
        showFilePreview();
      };
      reader.readAsDataURL(file);
    }
    function showFilePreview() { const existing = document.querySelector('.file-preview'); if (existing) existing.remove(); const preview = document.createElement('div'); preview.className = 'file-preview'; preview.innerHTML = `<span class="file-preview-icon">${pendingFile.type.startsWith('image/') ? 'üñºÔ∏è' : 'üé¨'}</span><span class="file-preview-name">${pendingFile.name}</span><button class="file-preview-remove" onclick="clearFilePreview()">‚úï</button>`; const inputWrapper = document.querySelector('.input-wrapper'); inputWrapper.appendChild(preview); }
    function clearFilePreview() { pendingFile = null; document.getElementById('fileInput').value = ''; const p = document.querySelector('.file-preview'); if (p) p.remove(); }

    // ---------- misc / notifications / UI ----------
    function getCurrentTime() { const now = new Date(); return now.toLocaleTimeString('en-US', { hour: '2-digit', minute:'2-digit', hour12:true }); }
    function playNotificationSound() { if (!soundEnabled) return; try { const audioContext = new (window.AudioContext || window.webkitAudioContext)(); const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.frequency.value = 800; oscillator.type = 'sine'; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.3); } catch (e) { console.warn('play sound failed', e); } }

    async function showNotification(message) {
      if (!notificationsEnabled || isInDNDPeriod() || isWindowFocused) return;
      if (Notification.permission !== 'granted') return;
      let body = message.content;
      if (message.encrypted && encryptionKey) {
        try { const key = cachedCryptoKey || await getEncryptionKey(encryptionKey); body = await decryptMessage(message.content, key); } catch (e) { body = '[Encrypted]'; }
      }
      const n = new Notification(`${message.author} sent a message`, { body: (body || '').substring(0,120), icon: 'üí¨' });
      n.onclick = () => { window.focus(); n.close(); };
      playNotificationSound();
    }

    // ---------- join / settings / credentials ----------
    async function joinChat() {
      const input = document.getElementById('usernameInput');
      const keyInput = document.getElementById('encryptionKeyInput');
      const name = input.value.trim(); const key = keyInput.value.trim();
      if (!name) { alert('Please enter a username'); return; }
      if (!key) { alert('Please enter an encryption key'); return; }
      if (key.length < 6) { alert('Encryption key must be at least 6 characters'); return; }

      username = name; encryptionKey = key;
      saveCredentials(username, encryptionKey);
      markAsReturningUser();

      document.getElementById('setupScreen').classList.add('hidden');
      document.getElementById('chatContainer').classList.remove('hidden');
      document.getElementById('inputArea').classList.remove('hidden');
      document.getElementById('currentUser').textContent = username;
      document.getElementById('roomInfo').textContent = `Room: ${roomId} üîí`;

      try { cachedCryptoKey = await getEncryptionKey(encryptionKey); } catch(e){ console.warn('Could not derive key at join:', e); cachedCryptoKey = null; }

      if (isFirebaseConfigured && isFirebaseConnected) {
        attachMessagesListener();
      } else {
        startLocalPolling();
      }

      await renderMessages();
      addSystemMessage(`${username} joined the chat`);
      document.getElementById('messageInput').focus();
    }

    function saveCredentials(username, key) { const remember = document.getElementById('rememberMe').checked; if (remember) { const credentials = { username, key, savedAt: new Date().toISOString() }; localStorage.setItem(CREDENTIALS_KEY, JSON.stringify(credentials)); document.getElementById('clearCredsBtn').style.display = 'block'; } else { localStorage.removeItem(CREDENTIALS_KEY); } }
    function loadSavedCredentials() { const saved = localStorage.getItem(CREDENTIALS_KEY); if (saved) { try { const c = JSON.parse(saved); document.getElementById('usernameInput').value = c.username || ''; document.getElementById('encryptionKeyInput').value = c.key || ''; document.getElementById('rememberMe').checked = true; document.getElementById('clearCredsBtn').style.display = 'block'; } catch (e) { console.error('Error loading creds', e); } } }
    function clearSavedCredentials() { if (!confirm('Clear saved username and encryption key?')) return; localStorage.removeItem(CREDENTIALS_KEY); document.getElementById('usernameInput').value = ''; document.getElementById('encryptionKeyInput').value = ''; document.getElementById('rememberMe').checked = false; document.getElementById('clearCredsBtn').style.display = 'none'; document.getElementById('firstTimeInfo').style.display = 'block'; localStorage.removeItem(FIRST_TIME_KEY); alert('Saved credentials cleared!'); }
    function checkFirstTimeUser() { const hasVisited = localStorage.getItem(FIRST_TIME_KEY); const infoBox = document.getElementById('firstTimeInfo'); if (hasVisited) infoBox.style.display = 'none'; else infoBox.style.display = 'block'; }
    function markAsReturningUser() { localStorage.setItem(FIRST_TIME_KEY, 'true'); }

    function addSystemMessage(text) { const container = document.getElementById('chatContainer'); const welcome = container.querySelector('.welcome-screen'); if (welcome) welcome.remove(); const systemMsg = document.createElement('div'); systemMsg.className = 'system-message'; systemMsg.textContent = `// ${text}`; container.appendChild(systemMsg); container.scrollTop = container.scrollHeight; }

    // UI helpers
    function autoResize(textarea) { textarea.style.height = 'auto'; textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px'; }
    const usernameInput = document.getElementById('usernameInput');
    const keyInput = document.getElementById('encryptionKeyInput');
    usernameInput.addEventListener('keypress', e => { if (e.key === 'Enter') { e.preventDefault(); keyInput.focus(); }});
    keyInput.addEventListener('keypress', e => { if (e.key === 'Enter') joinChat(); });

    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('input', function(){ autoResize(this); });
    messageInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }});

    window.addEventListener('focus', () => { isWindowFocused = true; if (username) renderMessages(); });
    window.addEventListener('blur', () => { isWindowFocused = false; });

    // Notification / DND stubs (you had implementations earlier; reuse or extend)
    async function toggleNotifications() { /* reuse your implementation if desired */ }
    function toggleDND() { /* reuse */ }
    function updateDNDMode() { /* reuse */ }
    function toggleSound() { /* reuse */ }
    function testNotification() { /* reuse */ }

    // start up
    window.addEventListener('DOMContentLoaded', () => {
      loadSavedCredentials();
      checkFirstTimeUser();
      updateConnectionUI();
      if (!isFirebaseConfigured) startLocalPolling();
    });

    // Unhandled promise rejection logging
    window.addEventListener('unhandledrejection', event => { console.error('Unhandled promise rejection:', event.reason); });

    // small helper expected by markup
    function toggleSettings() { document.getElementById('settingsPanel')?.classList.toggle('open'); }
    </script>
</body>
</html>
